## 服务器并发模型
### IO模型
#### 阻塞IO
阻塞IO执行的系统调用可能因为无法立即完成而被操作系统挂起，直到IO事件完成，再唤醒线程。
#### 非阻塞IO
非阻塞IO执行的系统调用总是立刻返回，而不管IO事件是否已经发生。
#### 同步IO
同步IO通知的是IO就绪事件，用户代码自行执行IO操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区）。
#### 异步IO
异步IO通知的是IO操作完成的事件，用户代码无需再进行IO操作，当IO事件就绪后内核来执行IO操作（提前给内核标记好数据的读缓冲区，数据到来时，内核负责将数据从内核缓冲区拷贝到用户缓冲区）。
#### IO复用
IO复用，应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数将就绪的事件通知给应用程序，IO复用技术提高效率的原因在于IO复用可以同时监听多个IO事件。

---
###	Reactor模型
同步IO实现Reactor模型，该模型下主线程只负责监听文件描述符上是否有事件发生，有的话则将事件通知给工作线程去处理；主线程不做有实质性的工作，读写数据，接受新的连接，以及处理客户请求均由工作线程处理。
<br/><br/>
![Reactor (1)](https://user-images.githubusercontent.com/91582638/135866372-ea3b9327-19ee-4622-9b04-0e89141a5b2f.png)


### Proactor模型
异步IO实现Proactor，该模型下所有的IO操作都交给主线程和内核去处理，工作线程仅负责业务逻辑，主线程调用aio_read给内核注册读完成事件，内核将数据读取完成后，向应用程序发送信号，信号触发工作函数处理用户消息。
<br/><br/>
![Proactor](https://user-images.githubusercontent.com/91582638/135866407-709168c1-44f0-4fee-8287-7e0b3af1272a.png)

### 模拟Proactor模型(项目中使用)
同步IO实现Proactor，该模型下所有的IO操作都交给主线程去做，工作线程仅负责业务逻辑，主线程检测到IO事件后，进行IO操作，IO事件操作完成后，主线程将读取到的消息放入消息队列中，业务线程从消息队列中取出消息，处理用户请求。
<br/><br/><br/>
![MyProactor (1)](https://user-images.githubusercontent.com/91582638/135867505-e53333d3-e4fc-4891-bb2d-8062d7773a6e.png)


#### 主线程
负责调用IO复用函数获取IO就绪事件，并对IO就绪的文件符进行IO操作（ListenFd的读事件-新的用户接入，ClientFd的读事件-用户发来消息）。
<br/>线程数目设置为一个（如果短时间内有大量的用户接入，可以加大线程数，加快用户接入的速度）。
#### 业务线程
负责处理用户发来的消息，主要的业务逻辑执行部分，当有数据要发送时，将待发送的数据放入待发送数据队列，发消息线程来负责数据的发送。
线程数目设置为二十个，服务器主要的业务执行部分，由连接池对业务线程进行管理。
#### 发消息线程
负责消息的发送，发消息线程先调用send发送数据，send失败且错误码为EAGIN时，说明缓冲区满、暂时发送不了，则给用户连接注册写事件，让主线程来负责这部分数据的发送。
线程数目设置为一个，缓冲区满导致发送数据失败的情况并不常见。


