- [池](#池)
	- [连接池](#连接池)
		- [连接](#连接)
		- [基本功能](#基本功能)
			- [数据结构](#数据结构)
			- [API](#api)
		- [线程安全](#线程安全)
			- [问题分析](#问题分析)
		- [延迟回收](#延迟回收)
		- [废包检测](#废包检测)
# 池
    池是一组提前分配好的静态资源，需要获取资源时，直接从池中获取，提高了运行效率。

- **提前创建** - 服务器的储存资源相对充裕，提前创建可以避免程序运行时的动态申请，如动态申请堆上的内存需要操作系统内核参与，还可能发生缺页中断、还有从内核态到用户态的切换，这些都会降低程序的运行效率。

- **静态资源** - 池中的资源提前创建，创建多少资源呢，这就需要对资源数量的提前估计，如果过少，则只能等待回收已分配的资源，这样将导致资源获取不及时，响应缓慢。
- **泛用性** - 池是一种思想，内存池-申请的内存块大小是不确定的，需要将获取的内存划分为不同的大小，便于分配、提高内存利用率；连接池-用户的连接数据用一个结构体保存，内存块大小是确定的，主要用来记录用户的信息、状态。
----
## 连接池
　　提前创建出一组连接（默认1024个，即可为1024个接入用户分配连接），在连接池中储存这些连接，当用户接入时为用户分配连接，当用户断开时回收连接。
### 连接

```c
typedef struct connection  *lp_connection;   //lp_connection是一个指向连接connection的指针
struct connection                            //该结构表示一个用户连接
{       //基本信息
	int 				fd;				//套接字句柄socket
	sockaddr			s_sockaddr;			//客户端的地址信息
	handler_pt			rhandler;			//读事件的处理函数
	handler_pt			whandler;			//写事件的处理函数
	uint64_t			iCurrsequence; 			//序号，主要用于检测废包，当连接断开时+1
	uint32_t			events;				//和epoll事件有关
	//收包相关
	unsigned char 			curStat;			//当前收包状态
	char				*precvbuf；			//接受数据的缓冲区的指针
	//用户状态
	unsigned char			userStat;			//记录用户是否已注册、是否是VIP用户
	... 可扩展
};
```
---
### 基本功能
    使用链表实现连接池，对连接的排列顺序没有要求，在保存链表头的情况下，链表可以快速访问到下一个可用的连接。
#### 数据结构
```c++
//连接池相关的数据
std::list<lp_connection>       m_connectionList;                      //连接列表【储存所有连接】
std::list<lp_connection>       m_freeconnectionList;                  //空闲连接列表【储存可用连接】
std::atomic<int>               m_total_connection_n;                  //连接池总连接数
std::atomic<int>               m_free_connection_n;                   //连接池空闲连接数
pthread_mutex_t                m_connectionMutex;                     //连接相关互斥量，互斥访问m_freeconnectionList，m_connectionList
std::list<lp_connection>       m_recyconnectionList;                  //将要释放的连接放这里【储存待回收的连接】
int                            m_RecyConnectionWaitTime;              //等待这么些秒后才回收连接
```
#### API
```c++
//连接池相关的调用接口
void initConnection();                                                //初始化连接池
void clearConnection();                                               //回收连接池
lp_connection get_connection(int isock);                              //从连接池中获取一个空闲连接
void free_connection(lp_connection pConn);                            //归还参数pConn所代表的连接到到连接池中	
void inRecyConnectQueue(lp_connection pConn);                         //将要回收的连接放到一个队列中来
```


![连接池ioo](https://user-images.githubusercontent.com/91582638/135753592-ab832423-faaa-4c9a-a73d-91bf3ea0cb70.png)
<br/>
<br/>

----
### 线程安全
`服务器并发模型`\\简单介绍服务器的相关线程
使用到连接资源的线程：<br/>
主线程<br/>
　1、用户接入->分配连接 2、用户断开->归还连接<br/>
业务线程<br/>
　1、用户消息处理->访问连接的内容、修改连接的内容<br/>
　当主线程检测到用户断开时，会将旧用户的连接回收再分配给新的用户，而业务线程可能还在处理旧用户之前的消息，修改旧用户的连接数据，而此时连接已被分配给新用户，就会出现`由于多线程同时操作连接资源，导致连接数据错误的现象`。 <br/> <br/>
　![连接池_逻辑错误 (2)](https://user-images.githubusercontent.com/91582638/135746095-24030731-ac4d-407b-b190-bd199c704e08.png)<br/><br/>
<br/>

#### 问题分析
　　出现这种问题主要的原因是在连接回收前没有确认连接是否被使用，如果连接还在被业务线程使用，则应该等到连接使用完毕后再回收。<br/>
``　　事件A-连接被主线程回收、事件B-连接被业务线程使用，两个线程需要互斥的访问的连接，可以使用互斥量来实现该逻辑，但互斥量的话，需要为每个连接都设置一个对应的互斥量，这样开销过大。``
<br/><br/>

---

### 延迟回收
实现：主线程不立刻去回收连接，而是先将待回收的连接在t1时刻放入-待回收连接队列中，创建出一个新的线程来回收-待回收连接队列中的连接，每个连接回收前都会先检测当前时刻t2,是否满足 t2>(t1+60)，满足，则说明该连接已在-待回收连接队列中等待60s、当前已经没有业务线程还在使用该连接，可回收，否则则不行。
<br/><br/>
![连接池_延迟 (1)](https://user-images.githubusercontent.com/91582638/135755524-f63d1678-eb6f-4a31-b051-c729989fc0a7.png)
<br/><br/>
`延迟回收的缺点`：因为连接需要延迟回收，如果在短时间出现大量的短连接，则释放后短连接被不能立刻被回收，此时因为连接池中的连接耗完，分配不了新的连接，就会导致对新的用户连接响应缓慢。
<br/><br/>

---
### 废包检测
主线程：处理用户连接 ，  业务线程：处理用户消息；用户连接的处理和用户消息的处理分别在两个线程中进行。<br/>存在一种情况：当主线程检测到用户断开时，业务线程还在继续处理用户消息（这里认为用户断开后，就无需再处理用户消息）。
为避免业务线程对废弃的数据包进行处理，通过比较不同时刻序列号的值来判断废包，丢弃废包。

![连接池_废包检测](https://user-images.githubusercontent.com/91582638/135748679-b142d612-a162-403f-9261-60bf6cbd221a.png)

