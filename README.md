#连接池
       池是一组资源的集合，这组资源在程序开启业务逻辑之前就被完全创建好，提前分配好了静态资源，程序运行时，当有新的客户连接接入时则直接从池中获取，提高了运行效率。

- **提前创建** - 服务器的储存资源相对充裕，提前创建可以避免程序运行时的动态申请，动态的申请堆上的内存需要操作系统内核参与，还可能发生缺页中断（需要内核再去分配资源）、还有从内核态到用户态的切换，这些都会降低程序的运行效率。

- **静态资源** - 池中的资源提前创建，创建多少资源呢，这就需要对资源数量的提前估计，如果过少，后面要么不给连接分配资源(造成相应速度慢)，要么再去动态的创建，动态创建的话则需要再去回收.
- **泛用性** - 池是一种思想，内存池-申请的内存块大小是不确定的，连接池-用户的连接数据用一个结构体保存，内存块大小是确定的，主要用来记录用户的信息、状态。

##用户连接

//(1)该结构表示一个TCP连接【客户端主动发起的、Nginx服务器被动接受的TCP连接】
```c
struct ngx_connection_s
{
    //基本信息
	int 				fd;					//套接字句柄socket
	sockaddr			s_sockaddr;			//客户端的地址信息
	handler_pt			rhandler;			//读事件的处理函数
	handler_pt			whandler;			//写事件的处理函数
	uint64_t			iCurrsequence; 		//序号，主要用于检测废包，当连接断开时+1
	uint32_t			events;				//和epoll事件有关
	//收包相关
	unsigned char 		curStat;			//当前收包状态
	char				*precvbuf；			//接受数据的缓冲区的指针
	//用户状态
	unsigned char		userStat;			//记录用户是否已注册、是否是VIP用户
	... 可扩展
};
```

##连接池

使用链表实现，主要有 get-获取一个连接）和 put-归还一个连接），顺序无关，在保存链表头的情况下，链表可以快速访问到下一个连接。
###API
###线程安全
服务器并发模型
哪些线程会getOne获取连接
1、主线程在新用户接入时会分配连接
访问连接的内容
1、业务线程会访问连接来获取用户的状态。
回收连接
1、主线程在检测到用户断开后，会回收连接。
T1时刻主线程ThreadA回收连接Connect1时，业务线程TheadB仍在对连接Connect1进行业务处理。
T2时刻，业务线程ThreadB业务处理完了之后，再去设置连接Connect1的数据，此时连接Connect1已被分配给新的用户了，逻辑上出现了错误。

出现这种问题主要的原因是在连接回收前没有确认连接是否还被使用，如使用-则应该等到连接被使用完再回收，没有被使用则立即回收。
可以看到 事件A-连接被主线程回收 事件B-连接被业务线程使用
两个事件需要互斥的访问的连接，可以使用互斥量来实现该逻辑，但互斥量的话，需要为每个连接都设置一个对应的互斥量，这样开销可能比较大。
这里采用延迟回收技术来进行处理，
实现：当检测到用户断开连接时
主线程不立刻去回收连接，而是先将待回收的连接在t1时刻放入 待回收连接队列中，创建出一个新的线程来回收连接队列中的连接并回收连接，对每个连接进行回收时都会先检测当前时刻t2是否满足 t2>(t1+60)，满足，则说明该连接已等待60s、当前已经没有业务线程还在使用该连接，可以回收，否则则不行。
延迟的意义：
这里认为业务线程对每个连接的处理不会超过60s,说60s后业务线程就不会再去访问连接中的资源，所以要回收连接时先将连接回收到连接队列中，然后再去延迟等待60s后，由回收线程去处理。
延迟回收的优点：
延迟回收的缺点：因为连接需要延迟回收，因此如果出现在短时间出现大量的短链接，则使用完毕后的短连接不能立刻回收，此时因为连接池中的连接耗完，分配不了新的连接，就会导致对用户的反响缓慢。

###废包检测


